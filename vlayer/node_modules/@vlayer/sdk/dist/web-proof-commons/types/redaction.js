import { z } from "zod";
export const RedactRequestHeadersSchema = z.object({
    request: z.object({
        headers: z.array(z.string()),
    }),
});
export const RedactRequestHeadersExceptSchema = z.object({
    request: z.object({
        headers_except: z.array(z.string()),
    }),
});
export const RedactRequestUrlQueryParamSchema = z.object({
    request: z.object({
        url_query: z.array(z.string()),
    }),
});
export const RedactRequestUrlQueryParamExceptSchema = z.object({
    request: z.object({
        url_query_except: z.array(z.string()),
    }),
});
export const RedactResponseHeadersSchema = z.object({
    response: z.object({
        headers: z.array(z.string()),
    }),
});
export const RedactResponseHeadersExceptSchema = z.object({
    response: z.object({
        headers_except: z.array(z.string()),
    }),
});
export const RedactResponseJsonBodySchema = z.object({
    response: z.object({
        json_body: z.array(z.string()),
    }),
});
export const RedactResponseJsonBodyExceptSchema = z.object({
    response: z.object({
        json_body_except: z.array(z.string()),
    }),
});
export const RedactionItemSchema = z.union([
    RedactRequestHeadersSchema,
    RedactRequestHeadersExceptSchema,
    RedactRequestUrlQueryParamSchema,
    RedactRequestUrlQueryParamExceptSchema,
    RedactResponseHeadersSchema,
    RedactResponseHeadersExceptSchema,
    RedactResponseJsonBodySchema,
    RedactResponseJsonBodyExceptSchema,
]);
// Define the individual types
const checkConflictingItems = (items) => (getFirstItem, getSecondItem) => {
    const hasFirst = items.some(getFirstItem);
    const hasSecond = items.some(getSecondItem);
    return !(hasFirst && hasSecond);
};
const ensureNoResponseHeadersConflict = (items) => {
    const hasResponseHeaders = (item) => "response" in item &&
        "headers" in item.response &&
        item.response.headers.length > 0;
    const hasResponseHeadersExcept = (item) => "response" in item &&
        "headers_except" in item.response &&
        item.response.headers_except.length > 0;
    return checkConflictingItems(items)(hasResponseHeaders, hasResponseHeadersExcept);
};
const ensureNoResponseJsonBodyConflict = (items) => {
    const hasResponseJsonBody = (item) => "response" in item &&
        "json_body" in item.response &&
        item.response.json_body.length > 0;
    const hasResponseJsonBodyExcept = (item) => "response" in item &&
        "json_body_except" in item.response &&
        item.response.json_body_except.length > 0;
    return checkConflictingItems(items)(hasResponseJsonBody, hasResponseJsonBodyExcept);
};
const ensureNoRequestHeadersConflict = (items) => {
    const hasRequestHeaders = (item) => "request" in item &&
        "headers" in item.request &&
        item.request.headers.length > 0;
    const hasRequestHeadersExcept = (item) => "request" in item &&
        "headers_except" in item.request &&
        item.request.headers_except.length > 0;
    return checkConflictingItems(items)(hasRequestHeaders, hasRequestHeadersExcept);
};
const ensureNoRequestUrlQueryParamConflict = (items) => {
    const hasRequestUrlQuery = (item) => "request" in item &&
        "url_query" in item.request &&
        item.request.url_query.length > 0;
    const hasRequestUrlQueryExcept = (item) => "request" in item &&
        "url_query_except" in item.request &&
        item.request.url_query_except.length > 0;
    return checkConflictingItems(items)(hasRequestUrlQuery, hasRequestUrlQueryExcept);
};
export const RedactionItemsArray = z
    .array(RedactionItemSchema)
    .refine(ensureNoResponseHeadersConflict, {
    message: "Cannot have both response headers and response headers_except",
})
    .refine(ensureNoResponseJsonBodyConflict, {
    message: "Cannot have both response json_body and response json_body_except",
})
    .refine(ensureNoRequestHeadersConflict, {
    message: "Cannot have both request headers and request headers_except",
})
    .refine(ensureNoRequestUrlQueryParamConflict, {
    message: "Cannot have both request url_query and request url_query_except",
});
export function getRedactionConfig(provingSessionConfig) {
    const notarizeStep = provingSessionConfig.steps.find((step) => step.step === "notarize");
    const redactionConfig = notarizeStep !== undefined ? notarizeStep.redact : [];
    return redactionConfig;
}
//# sourceMappingURL=redaction.js.map