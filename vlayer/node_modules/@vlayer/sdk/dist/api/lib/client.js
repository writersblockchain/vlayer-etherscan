import {} from "./types/vlayer.js";
import {} from "./types/webProofProvider.js";
import { prove, waitForProof } from "../prover/index.js";
import { createExtensionWebProofProvider } from "../webProof/index.js";
import { decodeFunctionResult, } from "viem";
import { MessageFromExtensionType, ZkProvingStatus, } from "../../web-proof-commons/index.js";
import {} from "./types/viem.js";
import {} from "./types/vlayer.js";
import { HttpAuthorizationError, httpAuthorizationErrorWithNote, } from "./errors.js";
import { match, P } from "ts-pattern";
function dropEmptyProofFromArgs(args) {
    if (Array.isArray(args)) {
        return args.slice(1);
    }
    return [];
}
export const createVlayerClient = ({ url = "http://127.0.0.1:3000", webProofProvider, token, } = {
    url: "http://127.0.0.1:3000",
}) => {
    const resultHashMap = new Map();
    if (!webProofProvider) {
        webProofProvider = createExtensionWebProofProvider({ token });
    }
    return {
        prove: async ({ address, proverAbi, functionName, chainId, gasLimit, args, }) => {
            webProofProvider.notifyZkProvingStatus(ZkProvingStatus.Proving);
            try {
                const hash = await prove(address, proverAbi, functionName, args, chainId, url, gasLimit, token);
                resultHashMap.set(hash.hash, [proverAbi, functionName]);
                return hash;
            }
            catch (error) {
                webProofProvider.notifyZkProvingStatus(ZkProvingStatus.Error);
                const errorWithNote = match(error)
                    .with(P.instanceOf(HttpAuthorizationError), (error) => httpAuthorizationErrorWithNote(error))
                    .otherwise((error) => error);
                throw errorWithNote;
            }
        },
        waitForProvingResult: async ({ hash, numberOfRetries = 900, sleepDuration = 3000, }) => {
            try {
                const { data } = await waitForProof(hash, url, token, numberOfRetries, sleepDuration);
                const savedProvingData = resultHashMap.get(hash.hash);
                if (!savedProvingData) {
                    throw new Error("No result found for hash " + hash.hash);
                }
                const [proverAbi, functionName] = savedProvingData;
                const result = dropEmptyProofFromArgs(decodeFunctionResult({
                    abi: proverAbi,
                    data: data.evm_call_result,
                    functionName,
                }));
                webProofProvider.notifyZkProvingStatus(ZkProvingStatus.Done);
                return [data.proof, ...result];
            }
            catch (error) {
                webProofProvider.notifyZkProvingStatus(ZkProvingStatus.Error);
                const errorWithNote = match(error)
                    .with(P.instanceOf(HttpAuthorizationError), (error) => httpAuthorizationErrorWithNote(error))
                    .otherwise((error) => error);
                throw errorWithNote;
            }
        },
        proveWeb: async function ({ address, proverAbi, functionName, chainId, gasLimit, args, }) {
            const webProofPlaceholder = args[0];
            const commitmentArgs = args.slice(1);
            const webProofPromise = new Promise((resolve, reject) => {
                webProofProvider.addEventListeners(MessageFromExtensionType.ProofDone, ({ payload: { presentationJson, decodedTranscript } }) => {
                    resolve({ presentationJson, decodedTranscript });
                });
                webProofProvider.addEventListeners(MessageFromExtensionType.ProofError, ({ payload: { error } }) => {
                    reject(new Error(error));
                });
            });
            webProofProvider.requestWebProof({
                proverCallCommitment: {
                    address,
                    proverAbi,
                    functionName,
                    commitmentArgs,
                    chainId,
                },
                logoUrl: webProofPlaceholder.logoUrl,
                steps: webProofPlaceholder.steps,
            });
            const webProof = await webProofPromise;
            const hash = await this.prove({
                address,
                functionName,
                chainId,
                gasLimit,
                proverAbi,
                args: [
                    {
                        webProofJson: JSON.stringify({
                            presentationJson: webProof.presentationJson,
                        }),
                    },
                    ...commitmentArgs,
                ],
            });
            return hash;
        },
    };
};
//# sourceMappingURL=client.js.map