import { encodeFunctionData, } from "viem";
import { ProofState, } from "../lib/types/vlayer.js";
import { match } from "ts-pattern";
import { v_call } from "./v_call.js";
import { v_getProofReceipt } from "./v_getProofReceipt.js";
import { foundry } from "viem/chains";
import { v_versions } from "./v_versions.js";
import { checkVersionCompatibility } from "../utils/versions.js";
import meta from "../../../package.json" with { type: "json" };
const sdkVersion = meta.version;
async function preverifyVersions(url, shouldPreverify, token) {
    if (shouldPreverify) {
        const proverVersions = await v_versions(url, token);
        checkVersionCompatibility(proverVersions.api_version, sdkVersion);
    }
}
export async function prove(prover, abi, functionName, args, chainId = foundry.id, url = "http://127.0.0.1:3000", gasLimit = 10_000_000, token, options = { preverifyVersions: false }) {
    await preverifyVersions(url, !!options.preverifyVersions);
    const calldata = encodeFunctionData({
        abi: abi,
        functionName: functionName,
        args: args,
    });
    const call = { to: prover, data: calldata, gas_limit: gasLimit };
    const context = {
        chain_id: chainId,
    };
    const hash = await v_call(call, context, url, token);
    return { hash };
}
export async function getProofReceipt(hash, url = "http://127.0.0.1:3000", token) {
    const resp = await v_getProofReceipt(hash.hash, url, token);
    handleErrors(resp);
    return resp;
}
const handleErrors = ({ status, state, error }) => {
    if (status === 0) {
        match(state)
            .with(ProofState.AllocateGas, () => {
            throw new Error(`Allocating gas failed with error: ${error}`);
        })
            .with(ProofState.Preflight, () => {
            throw new Error(`Preflight failed with error: ${error}`);
        })
            .with(ProofState.Proving, () => {
            throw new Error(`Proving failed with error: ${error}`);
        })
            .exhaustive();
    }
};
export async function waitForProof(hash, url, token, numberOfRetries = 900, sleepDuration = 3000) {
    for (let retry = 0; retry < numberOfRetries; retry++) {
        const { state, data, metrics } = await getProofReceipt(hash, url, token);
        if (state === ProofState.Done) {
            return { data, metrics };
        }
        await sleep(sleepDuration);
    }
    throw new Error(`Timed out waiting for ZK proof generation after ${numberOfRetries * sleepDuration}ms. Consider increasing numberOfRetries.`);
}
async function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
//# sourceMappingURL=prover.js.map