import {} from "../../lib/types/webProofProvider.js";
import { EXTENSION_STEP, MessageToExtensionType, ZkProvingStatus, assertUrl, assertUrlPattern, RedactionItemsArray, MessageFromExtensionType, } from "../../../web-proof-commons/index.js";
import debug from "debug";
const log = debug("vlayer:WebProof:provider");
const EXTENSION_ID = "jbchhcgphfokabmfacnkafoeeeppjmpl";
class ExtensionWebProofProvider {
    notaryUrl;
    wsProxyUrl;
    token;
    port = null;
    listeners = {};
    constructor(notaryUrl, wsProxyUrl, token) {
        this.notaryUrl = notaryUrl;
        this.wsProxyUrl = wsProxyUrl;
        this.token = token;
    }
    notifyZkProvingStatus(status) {
        if (typeof chrome !== "undefined") {
            // Chrome does not provide reliable api to check if given extension is installed
            // what we could do is to use management api but
            // 1) this will need to provided extra permission
            // 2) still is not reliable because this api becomes defined when first extension that uses it is installed
            // so still will need to try catch
            try {
                chrome.runtime.sendMessage(EXTENSION_ID, {
                    type: MessageToExtensionType.NotifyZkProvingStatus,
                    payload: { status },
                });
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
            }
            catch (e) {
                log("Cant send message", "look that extension is not installed ");
            }
        }
    }
    connectToExtension() {
        if (!this.port) {
            this.port = chrome.runtime.connect(EXTENSION_ID);
            this.port.onDisconnect.addListener(() => {
                this.port = null;
                this.connectToExtension();
            });
            this.port.onMessage.addListener((message) => {
                this.listeners[message.type]?.forEach((cb) => cb(message));
            });
        }
        return this.port;
    }
    addEventListeners(messageType, listener) {
        this.connectToExtension();
        if (!this.listeners[messageType]) {
            this.listeners[messageType] = [];
        }
        this.listeners[messageType].push(listener);
    }
    closeSidePanel() {
        const port = this.connectToExtension();
        port.postMessage({
            type: MessageToExtensionType.CloseSidePanel,
        });
    }
    openSidePanel() {
        this.connectToExtension().postMessage({
            type: MessageToExtensionType.OpenSidePanel,
        });
    }
    requestWebProof(webProofRequest) {
        validateWebProofRequest(webProofRequest);
        this.connectToExtension().postMessage({
            type: MessageToExtensionType.RequestWebProof,
            payload: {
                notaryUrl: this.notaryUrl,
                wsProxyUrl: this.wsProxyUrl,
                token: this.token,
                logoUrl: webProofRequest.logoUrl,
                steps: webProofRequest.steps,
            },
        });
    }
}
const validateSteps = (steps) => {
    steps.forEach((step) => {
        if (step.step === EXTENSION_STEP.startPage) {
            assertUrl(step.url);
        }
        else {
            assertUrlPattern(step.url);
        }
        if (step.step === EXTENSION_STEP.notarize) {
            validateRedaction(step.redact ?? []);
        }
    });
};
const validateRedaction = (redaction) => {
    RedactionItemsArray.parse(redaction);
};
export const validateWebProofRequest = (webProofRequest) => {
    validateSteps(webProofRequest.steps);
};
export const createExtensionWebProofProvider = ({ notaryUrl = "https://test-notary.vlayer.xyz/v0.1.0-alpha.11", wsProxyUrl = "wss://test-wsproxy.vlayer.xyz", token, } = {}) => {
    return new ExtensionWebProofProvider(notaryUrl, wsProxyUrl, token);
};
//# sourceMappingURL=extension.js.map